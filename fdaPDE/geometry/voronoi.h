// This file is part of fdaPDE, a C++ library for physics-informed
// spatial and functional data analysis.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef __VORONOI_H__
#define __VORONOI_H__

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <list>

#include "../utils/symbols.h"
#include "utils.h"

#include <cmath>
#include <unsupported/Eigen/SparseExtra>

using UInt = int;

namespace fdapde {
namespace core {

// adaptor adapting a (Delanoy) triangulation to its dual Vornoi diagram
template <typename Triangulation> class Voronoi;

class ConvexPolygon{
    public:
      void set_points(vector<SVector<3>> points){
        points_ = points;
	UInt den = points.size();
	SVector<3> mean;

	for(auto i = 0; i<points.size(); i++){
	  mean = mean + points_[i];
	}

	// Build the centroid
	centroid = mean/den;
      }
      void set_adiacent_polygons(DVector<UInt> adiacent_polygons){adiacent_polygons_ = adiacent_polygons;} // positive indexes point internal faces neighbor; Otherwise Surface neighborus
      void set_adiacent_cell(UInt adiacent_cell){adiacent_cell_=adiacent_cell;}
      double measure(){ // since the polygon is convex, I just need to compute the triangle with respect the first point and any successive couple of points. If the polygon is open, the measure is set to -1
	if(this->closed()){
	  double result=0;
	  SVector<3> v1;
	  SVector<3> v2;
	  for(auto i=1; i<points_.size()-1; i++){ //from (1,2) to (n-1, n) // CHECK THE FORMULA FOR TRIANGLE IN 3D space!!!!
	    v1 = points_[i]-points_[0];
	    v2 = points_[i+1]-points_[i];
	    result += (v1.cross(v2)).norm();
	  }
	  return result;
	}else{
	  return -1; // NO measure is possible if polygon open
	}
      }
      bool closed(){
        if(adiacent_polygons_.size() <  points_.size()){
          this->closed = false;
        }else{
          this->closed = true;
        }
        
        return this->closed;
      }
      
      const vector<SVector<3>> & points() const {return this->points_;}; // Orderded points of the poligon, with end/init not repated. The polygon is counterclockwise ordered, such that the cell is indicated by the normal vector generated by three ordered points
      
      const DVector<UInt> & adiacent_polygons() const {return adiacent_polygons_;}; // Size = points_.rows(). Each element i represents the index of the Polygon adiacent to the segment points(i,...) - points(i+1,...). If the segment is adiacent to infinity, contains -1
      
      UInt adiacent_cell() const {
	return adiacent_cell_;
      }

      HyperPlane<2,3> supporting_plane(){
        return HyperPlane<2,3>(points_[0], points_[1], points_[2]); // Build the hyperplan from any three points of ConvexPolygon (at least 3 points always present)
      }
      
      bool check_Direction (SMatrix<3,2> segment){
	double value = (segment.col(0)-centroid).cross(segment.col(1)-segment.col(0)).dot((points_[0]-centroid).cross(points_[1] - points_[0]));
	return value > 0;
      }
      
      // This routine is of core importance. Implements the sutherland algorithm (adapted to the current polygon structure).
      // Input: - cut plane: the plane upon which we need to cut the Polygon of interesr
      //        - plane_index: index of the cutting plane (cutting polygon) inside the voronoi cell, used for adiacency operations (Yan aglorithm and clipping_by_surface routine)
      bool cut_by_plane(HyperPlane<2,3> cut_plane, UInt cut_plane_index){ //DMatrix<double> cut_points
        
        // NOTE: THE OUTPUT POLYGON MAY BE EMPTY? WE NEED TO HANDLE WELL THIS CASE!!! ---> to be checked in superior routine
        // Note: a point is inside if signed_distance >= 0, i.e. points on the border are inside. Moreover, we need to take special care if the intersection of segments with plane is one of the two points:   
        bool result = false;
        
        vector<SVector<3>> O_points;       // Output vertices
        DVector<UInt> O_adiacent_polygons; // Output connectivity vector
        
        UInt n = points_.rows();
        
        // Prepare data structures
        O_points.resize(0);
        O_adiacent_polygons.resize(0);
        
        // we need to take into account the maximum size
        UInt size=0;
        
        double offset_0 = 0; // Offset is just the distance with sign with respect to a point
        double offset_1 = 0; // Offset is just the distance with sign with respect to a point
        
        double dist_0=0;
        double dist_1=0;
        
        double intersection=0;
        
        double tol = 0.0000000001; // To avoid cancellation errors ---> Armonize with fdaPDE
        
        for(auto i = 0; i<n; i++){
        
          // Extract the current couple under analysis
          SVector<3> P0 = this->points_[i];
          SVector<3> P1 = P0;
          
          // Take care of the last point
          if(i==(n-1)){
            P1 = this->points_[0];
          }else{
            P1 = this->points_[i+1];
          }  
          
          // distance of current point
          offset_0 = (P0 - cut_plane.project(P0)).dot(cut_plane.norm());
          dist_0 = std::abs(offset_0);
          
          // distance of next point
          offset_1 = (P1 - cut_plane.project(P1)).dot(cut_plane.norm());
          dist_1 = std::abs(offset_1);
          
          if(offset_0 < 0 && offset_1>0 || offset_0>0 && offset_1 <0; || dist_0 < tol && offset_1 < 0 || dist 1 < tol && offset_0 < 0){
            result=true;
          }
          
          // Case both inside, current on plane and second outside, current inside and the other on plane
          if((offset_0 > tol && offset_0 > tol) || (dist_0 < tol && offset_1 > tol) || (offset_0 > tol && dist_1 < tol)){
            O_points.push_back(P0);
            O_adiacent_polygons(i)=adiacent_polygons_(i);
            size++;
          }
          
          // Current in, next out
          if(offset_0 > tol && offset_1 < -tol){
            // Find intersection
            intersection = dist_0 / (dist_0 + dist_1);
            O_points.push_back(P0);
            O_adiacent_polygons(i)=adiacent_polygons_(i);
            size++;
            // Add the novel vertex
            O_points.push_back(P0+intersection*(P1-P0)); // Add the novel intersection point 
            O_adiacent_polygons(i+1)=plane_index;
            size++;
          }
          
          // Current out, next in
          if(offset_0 < -tol && offset_1 > tol){
            // Find intersection
            intersection = dist_0 / (dist_0 + dist_1);
            O_points.push_back(P0+intersection*(P1-P0)); // Add the novel intersection point
            O_adiacent_polygons(i)=adiacent_polygons_(i);
            size++;
          }
          
          // Case current point is on the plane but the other is out or both on the plane
          if((dist_0 < tol && offset_1 < -tol) || (dist_0<tol && dist_1<tol)){ // Current on plane, next out of bound
            // Find intersection
            O_points.push_back(P0);
            O_adiacent_polygons(i)=plane_index;
            size++;
          }  
        
          // In the remaining cases: do nothing!
        }
        
        // Update the vertices and the adiacency structure
        this->points_ = O_points;
        this->adiacent_polygons = O_adiacent_polygons.head(size);
        
        return result; // There has been a cut, but we still need to handle the case of emplty lists!!!
        
      }

      void update_to_surface(list<SVector<3>> surface_limit, list<UInt> neighbors, const ConvexPolygon * plane_begin, const ConvexPolygon * plane_end){
	// To find where to place the list of segments, I just need to cycle and cut by the extremes of the
	// the idea is to first compute where is the intersection between the last segment and the sequence (entering), and a the same time computing where is the last intersection between last segment.
	// Then, we beed to keep just the inner points and the points of the line!!
	// Finally er send back the so modified

	//MOdify sutherland algorithm to find where to cut the elements
	std::vector<SVector<3>> O_points; // Output vertices
        DVector<UInt> O_adiacent_polygons; // Output connectivity vector

	UInt n = points_.rows();
        
        // Prepare data structures
        O_points.resize(0);
        
        // we need to take into account the maximum size
        UInt size=0;
        
        double offset_0_begin=0;
        double offset_1_begin=0;
	
	double offset_0_end=0;
	double offset_1_end=0;
        
        double tol = 0.0000000001; // To avoid cancellation errors +

	UInt index_begin;
	UInt index_end;

	for(auto i = 0; i<n; i++){
        
          // Extract the current couple under analysis
          SVector<3> P0 = this->points_[i];
          SVector<3> P1 = P0;
          
          // Take care of the last point
          if(i==(n-1)){
            P1 = this->points_[0];
          }else{
            P1 = this->points_[i+1];
          }  
          
          // distances from begin
          offset_0_begin = (P0 - plane_begin->project(P0)).dot( plane_begin->normal());
	  offset_1_begin = (P1 - plane_begin->project(P1)).dot(plane_begin->normal());
          
          // distances from end
          offset_0_end = (P0 - plane_end->project(P0)).dot( plane_end->normal());
	  offset_1_end = (P1 - plane_end->project(P1)).dot(plane_end->normal());
          
          // Current in, next out from last segment of surface segments
          if((offset_0_begin > tol) && (offset_1_begin < -tol)){
            index_end = i;
          }
          
          // Current out, next in from last segment of surface segments
          if((offset_0_end < -tol) && (offset_1_end > tol)){
	    if(i<n-1){
	      index_begin = i+1; 
	    }else{
	      index_begin = 0;
	    }
	    
          }
        
        }

	size = (index_end - index_begin + 1) + surface_limit.size();
	O_points.resize(size);
	O_adiacent_polygons.resize(size);
	
	if(index_begin < index_end){
	  for(auto i = index_begin; i< index_end +1; i++){
	    O_points[i-index_begin] = points_[i];
	    O_adiacent_polygons[i-index_begin] = adiacent_polygons_[i];
	  }
	}else{
	  for(auto i = index_begin; i< points_.size(); i++){
	    O_points[i-index_begin] = points_[i];
	    O_adiacent_polygons[i-index_begin] = adiacent_polygons_[i];
	  }

	  for(auto i = 0; i< index_end+1; i++){
	    O_points[i+points_.size()-index_begin] = points_[i];
	    O_adiacent_polygons[i+points_.size()-index_begin] = adiacent_polygons_[i];
	  }
	}

	auto iter_surf = surface_limit.begin();
	auto iter_adiacent = neighbors.begin();

	if(index_begin < index_end){
	  for(auto i =  index_end-index_begin+1; i < size; i++ ){
	    O_points[i] = *iter_surf;
	    O_adiacent_polygons[i] = *iter_adiacent;
	    iter_surf++;
	    iter_adiacent++;
	  }
	}else{
	  for(auto i = points_.size() - index_begin+index_end+1; i < size; i++ ){
	    O_points[i] = *iter_surf;
	    O_adiacent_polygons[i] = *iter_adiacent;
	    iter_surf++;
	    iter_adiacent++;
	  }
	}

	
        
        // Update the vertices and the adiacency structure
        this->points = O_points;
        this->adiacent_polygons = O_adiacent_polygons;
        
        return;
      } 
  

    private:
      std::vector<SVector<3>> points_; // Orderded points of the poligon, with end/init not repated. The polygon is counterclockwise ordered, such that the cell is indicated by the normal vector generated by three ordered points
      DVector<UInt> adiacent_polygons_; // Size = points.rows(). Each element i represents the index of the Polygon adiacent to the segment points(i,...) - points(i+1,...). If the segment is adiacent to infinity, contains -1
      bool closed;
      UInt adiacent_cell_; // index of the adiacent cell in the voronoi or -1 if it is not adiacent to anything, after clipping to surface
      SVector<3> centroid;
    };
    
    template <> class Voronoi<Triangulation<3, 3>> {
    public:
      static constexpr UInt local_dim = Triangulation<3,3>::local_dim;
      static constexpr UInt embed_dim = Triangulation<3,3>::embed_dim;
      
      Voronoi() = default;
      Voronoi(const Triangulation<3, 3> & mesh) : mesh_(&mesh) {   // constructs voronoi diagram from Delanoy triangulation	
	// Set the sites
	this->nodes_ = mesh_->nodes();
	
	// Build the actual unrestricted voronoi
	this->build_unrestricted_voronoi();
	
	// clip the surface with respect to the Voronoi, and update the cells
	this->cut_surface_to_cells();
	
	// Finally make a cycle over the Voronoi cells to check which are boundary
	this->nodes_markers_.resize(this->nodes_.rows());
	for(auto iter = this->cells_.begin(); iter != this->cells_.end(); iter++){
	  nodes_markers_(iter->first) = (iter->second).on_boundary();
	}
      }
      
      struct segment {
	SVector<3> p1, p2;
	UInt neighbor;
      };
	
      void build_unrestricted_voronoi(){ // This method will be invoked by the constructor to iniztialize the cells of the voronoi.
	
	// Idea: preallocate the space;
	//       then make a cycle across the faces of the triangulation. For each we have a segment (either infinite or finite)
	//       add the segment to the polygons associated to the edges
	//       finally sort-build the polygons (convex) by centroid;
	
	// This will contain the segments for each polygon for VoronoiCells
	std::vector<std::vector<std::vector<Segment>>> Segments; // This structure will store the segments of each polygon, one for every edge insisitng on a node. Final dim: n_nodes x n_edges_on_node x n_tets_insisiting on edge
	std::vector<std::map<UInt,UInt>> edges_to_poly; // Tis map is need to report the global voronoi index of an edge to the local index used to store the associated polygon in the cell, dim n_nodes
	std::vector<std::vector<UInt>> close_cell; // This structure contains the cell-cell adiacency info of a Polygon, dim n_nodes x n_edges_on_node
	vector<bool> analyzed_faces; // This structure keeps trace of the faces analyzed in the construction, so to save computational time, dim: n_faces in triangulation
	
	// Sizes and preallocation of space
	DVector<UInt> n_edges_to_cell; // Aux structure

	UInt n = mesh_->n_nodes();
	segments.resize(n);
	edges_to_poly.resize(n);
	close_cell.resize(n);
	n_edges_to_cell.resize(n);

	for(auto i =0; i<n;i++){
	  // at least one inside
	  n_edges_to_cell[i]=1;
	}

	// Fill the maps;
        for(auto edge = mesh_->edges_begin(); edge != mesh_->edges_end(); edge++){ //
	  auto P0 = edge->node_ids()(0); //
	  auto P1 = edge->node_ids()(1); //
	  UInt edge_id = edge.id(); // This exists;

	  edges_to_poly[P0].insert(edge_id,n_edges_to_cell[P0]);
	  n_edges_to_cell[P0]++;

	  edges_to_poly[P1].insert(edge_id,n_edges_to_cell[P1]);
	  n_edges_to_cell[P0]++;
	}

	for(auto i=0;i<n;i++){
	  segments[i].resize(n_edges_to_cell[i]);
	  close_cell[i].resize(n_edges_to_cell[i]);
	  for (auto j = 0; j < n_edges_to_cell[i]; j++){
	    segments[i][j].resize(0);
	    segments[i][j].serserve(6); // On average, we expext 6 faces to insist on an edge
	  }
	}
	
	analyzed_faces.reszize(mesh_->face_end() - mesh_->face_begin());
	for(auto i = 0; i < analyzed_faces.size(); i++){
	  analyzed_faces=false;
	}


	// Main cycle: we cycle over the faces, and add the appropriate segments to the nodes.
	// Since we need to employ the information of the tetrahedron used, we need make a cycle based on those.
	auto tet_0 = mesh_->cells_begin(); // Check with Palummo, syntax
	auto tet_1 = tet_0;

	// To be modified
	double M = 
	  (std::max(nodes_().col(0)) - std::min(nodes_().col(0)))*(std::max(nodes_().col(0)) - std::min(nodes_().col(0))) + 
	  (std::max(nodes_().col(1)) - std::min(nodes_().col(1)))*(std::max(nodes_().col(1)) - std::min(nodes_().col(1))) +
	  (std::max(nodes_().col(2)) - std::min(nodes_().col(2)))*(std::max(nodes_().col(2)) - std::min(nodes_().col(2))) ; // max distance in mesh

	for(auto tet = mesh_->cells_begin(); tet != mesh_->cells_end(); tet++ ){ // Note: we work on the faces of each tetrahedron
	  
	  for(auto face = tet->faces_begin(); face != tet->faces_end(); face++ ){ // for each face, do something only if the face hasn't been analyzed yet
	    if(!analyzed_faces[face->id()]){ // Only if the face hasn't been analyzed yet
	      segment seg;

	      if(face->on_boundary()){
		auto face_plane = face->supporting_plane(); // check with Palummo

		seg.p1 = tet->circumcenter();
		seg.p2 = tet->circumcenter() + face_plane.normal()*M; ////// DEFINE M as max of data norm, supposing NORMAL IS OUTGOING, check with palummo!!
	      }else{
	        auto neighbors = face->neighbors();
	        UInt neighbor = neighbors(0);
	        if(neighbor == tet->id()){
	          neighbor = neighbors(1);
	        }
		tet_1 = tet_0 + neighbor; // get the other tet

		seg.first = tet->circumcenter();
		seg.second = tet_1->circumcenter();
	      }

	      // Now, save the segments in each position
	      auto e0 = face.edges_begin();
	      auto e1 = e1 + 1;
	      auto e2 = e2 + 1;

	      auto p0 = e1.points_id()(0);
	      auto p1 = e1.points_id()(1);
	      auto p2 = e2.points_id()(0);
	      
	      if(p2==p1 || p2==p0){
	        p2 = e2.points_id()(1);
	      }

	      segment seg_1, seg_2, seg_3, seg_4, seg_5, seg_6;
	      seg_1 = seg;
	      seg_1.neighbor = edges_to_poly[p0][e2.id()];
	      seg_2 = seg;
	      seg_2.neighbor = edges_to_poly[p0][e0.id()];
	      seg_3 = seg;
	      seg_3.neighbor = edges_to_poly[p1][e1.id()];
	      seg_4 = seg;
	      seg_4.neighbor = edges_to_poly[p1][e0.id()];
	      seg_5 = seg;
	      seg_5.neighbor = edges_to_poly[p2][e2.id()];
	      seg_6 = seg;
	      seg_6.neighbor = edges_to_poly[p2][e1.id()];


	      segments[p0][edges_to_poly[e0.id()]].push_back(seg_1);

	      segments[p0][edges_to_poly[e2.id()]].push_back(seg_2);
	      
	      close_cell[p0][edges_to_poly[e0.id()]] = p1;
	      close_cell[p0][edges_to_poly[e2.id()]] = p2;
	      
	      segments[p1][edges_to_poly[e0.id()]].push_back(seg_3);
	      
	      segments[p1][edges_to_poly[e1.id()]].push_back(seg_4);
	      
	      close_cell[p1][edges_to_poly[e0.id()]] = p0;
	      close_cell[p1][edges_to_poly[e1.id()]] = p2;
	      
	      segments[p2][edges_to_poly[e1.id()]].push_back(seg_5);
	      
	      segments[p2][edges_to_poly[e2.id()]].push_back(seg_6);
	      
	      close_cell[p2][edges_to_poly[e2.id()]] = p0;
	      close_cell[p2][edges_to_poly[e1.id()]] = p1;
	    }
	  }
	}

	// Now I have a set of unsorted segments. I need to transform this into a ConvexPolygon, that is a list of points, ordered counter-clockwise with respect to the centroid
	// To do so, I define the following auxiliary routine
	ConvexPolygon build_convex_polygon(vector<segment> & segments, UInt adiacent_cell, SVector<3> site){
	  SVector<3> mean;
	  UInt den = 0;

	  for(auto i = 0; i< segments.size(); i++){
	    mean = mean + segments[i].p1 + segments[i].p2;
	    den = den + 2;
	  }

	  // Build the centroid
	  mean = mean/den; 

	  // Auxiliary structure used to build the sorted set of points. The key will be the angle with respect the centroid - first point of the polygon
	  map<double,segment> final_polygon;

	  Svector<3> v1 = segments[0].p1 - mean;
	  SVector<3> v2 = segments[0].p2 - segments[0].p1;

	  HyperPlane<2,3> plane(v1,v2);
	  SVector<3> normal = plane.normal();
	  if((site - plane.project(site)).dot(normal) < 0){
	    normal = -normal;
	  }

	  if((v1.cross(v2)).dot(normal) > 0){
	    final_polygon[0] = segments[0];
	  }else{
	    segment seg  = segments[0];
	    seg.p2 = segments[0].p1;
	    seg.p1 = segments[0].p2;
	    final_polygon[0] = seg;
	    v1 =  segments[0].p2 - mean;
	    v2 = -v2;
	  }
	  
	  for(auto i = 1; i<segments.size(); i++){
	    Svector<3> v3 = segments[i].p1 - mean;
	    SVector<3> v4 = segments[i].p2 - segments[i].p1;

	    if((v3.cross(v4)).dot(normal) > 0){ // Segment is already well positioned
	      // Compute the angle in 360 degrees w.r.t. the original axis
	      double angle = atan2(normal.dot(v3.cross(v1)),v3.dot(v1)); // Chck with palummo!!
	      final_polygon[angle] = segments[i];
	    }else{
	      segment seg  = segments[i];
	      seg.p2 = segments[i].p1;
	      seg.p1 = segments[i].p2;
	      v3 =  segments[i].p2 - mean;
	      v4 = -v4;

	      double angle = atan2(normal.dot(v3.cross(v1)),v3.dot(v1)); // Chck with palummo!!
	      final_polygon[angle] = segments[i];
	    }
	  }

	  // Finally build the actual polygon
	  vector<SVector<3>> points;
	  vector<UInt> adiacent;

	  points.resize(segments.size()+1);
	  adiacent.resize(segments.size());
	  points.push_back(final_polygon.begin()->p1);
	  for(auto iter = final_polygon.begin(); iter!= final_polygon.end(); iter++){
	    points.push_back(iter->p2);
	    adiacent.push_back(iter->neighbor);
	  }

	  // Closed or open
	  if((points.front()-points.back()).norm()<0.00005){ // Check tol with Palummo!!!
	    points.pop_back();
	  }

	  ConvexPolygon result;
	  result.set_points(points);
	  result.set_adiacent_polygons(adiacent);
	  result.set_adiacent_cell(adiacent_cell); 
	};

	
	// Final step requires to build the voronoi cells. To be harmonized with the VoronoiCell structure
	vector<VoronoiCell> cells;
	cells.resize(n);
	for(auto i = 0; i < n; i++){
	  std::vector<ConvexPolygon> Cell_i;
	  Cell_i.resize(segments[i].size());
	  for(auto j = 0; j < segments[i].size();j++){
	    Cell_i.push_back(build_convex_polygon(segments[i][j],close_cells[i][j]), nodes_.row(i)); // Check with Palummo nodes[i,] for the site, needed for ordering of the normal
	  }
	  cells[i].set_inner_faces(Cell_i);
	  cells[i].set_id(i);
	}

        // Add the cells to internal memory storage
	for(auto i = 0; i< n; i++){
	  this->cells_.insert({i, cells[i]}); 
	}
      };

      // This routine computes the surface polygons associated to each cell. The algorithm mimics the one of Yan, Wang, Levy, Liu (2013).
      // The core idea is to employ a FIFO queue:
      // We start from incident cell-triangle couples. We analyze it, and we can propose a successive incident cell-triangle couple in the queue
      // We employ a boolean matrix to avoid to analyze a couple twice
      void cut_surface_to_cells(){
	// The matrix is needed to avoid double analysis of the same cell-surface_tringle couple
	DMatrix<bool> incident_set;
	
	// Note: we can extract the info of adiacency by using the surface method of the mesh.
	// However, we have the problem of treating the map between this surface and the triangles that we use in the normal mesh. However, is this really a problem? Actually no, if we don't need to take care of the underlying tetrahedra ---> but we need to do that!!
	// Discuss with PALUMMO!!!
	auto surface_iterator = mesh_->boundary_faces_begin(); // CHECK Syntax with Palummo
	auto initial_face = surface_iterator;
	UInt n_faces = mesh_->boundary_faces_end()-surface_iterator;
	UInt n_nodes = mesh_->n_nodes();

	incident_set.resize(n_nodes, n_faces);
	for(auto i=0; i<n_nodes; i++){
	  for(auto j=0; j<n_faces; j++){
	    incident_set(i,j)=false;
	  }
	}

	// Create and initialize the FIFO queue.
	struct incident_cell_face_cuples{ // NB this structure contains just the indexes of the 
	  UInt cell;
	  UInt face;
	};

	std::list<incident_cell_face_cuples> FIFO_queue;
	incident_cell_face_cuples initial_couple;
	initial_couple.cell = surface_iterator->nodes()[0].id(); // Syntax check Palummo
	initial_couple.face = surface_iterator->id(); // Syntax ceck with Palummo
	FIFO_queue.push_back(initial_couple);
	incident_set(couple.cell, couple.face)=true;

	// Prepare the structures that will be used to build actually the surfaces, eventually substituted by apposite methods in voronoi cell (push_back in voronoi cell? Little space).
	std::vector<std::vector<ConvexPolygon>> Surfaces_polygons_collection;
	ConvexPolygon as_polygon(Simplex<2,3> * face){ // NOTE: should take an iterator
	  // To be implemented, ask Palummo; Main problem is to retrieve the adiacent polygons information on the surface!! INDEED WE CAN DO THIS USIG THE SURFACE METHOD; NO MORE!!, simply will be referred to the tringles of the sruface (the methods that will use this need to take this into account) (We will also need a transformation to internal map at the end, since the closeness is local)
	  // I need to deepen more this prolem
	  // Idea: before use the indices of surface mesh boundary, only at the last, build your map!!
	  // Build the list of points
	  vector<SVector<3>> points;
	  vector<UInt> adiacent_faces;
	  
	  // manual insertion
	  for(auto iter = face->edges_begin(); iter != face->edges_end(); iter++){
	    auto neigh = face->neighbors()(0);
	    if(neigh == face->id()){
	      neigh = face->neighbors()(1);
	    }
	    adiacent_faces.push_back(-1-neigh); // Negative index to comply with notation of ConvexPolygons
	  }
	    
	  
	  auto iter = face->edges_begin();
	  
	  UInt p0 = iter->node_ids()(0);
	  UInt p1 = iter->node_ids()(1);
	  
	  iter++;
	  
	  UInt p2 = iter->node_ids()(0);
	  if(p2==p1 || p2==p0){
	    UInt p2 = iter->node_ids()(1);
	  }
	  
	  points.push_back(nodes_.row(p0));
	  points.push_back(nodes_.row(p1));
	  points.push_back(nodes_.row(p2));
	  
	  SVector<3> v1 = nodes_.row(p1)-nodes_.row(p0);
	  SVector<3> v2 = nodes_.row(p2)-nodes_.row(p0);
	  
	  
	  if((v1.cross(v2)).dot(face->normal())<0){ // Hoping normal is oriented right, as it should be  CHECK
	    std::reverse(points.begin(), points.end());
	    std::reverse(adiacent_faces.begin(), adiacent_faces.end());
	  }
	  
	  ConvexPolygon poly;
	  poly.set_points(points);
	  poly.set_adiacent_polygons(adiacent_faces);
	  poly.set_adiacent_cell(-1):
	  
	  return poly;
	  
	  // RECHEK HERE
	};

	// Main construction cycle
	while(FIFO_queue.size() != 0){
	  incident_cell_face_cuples actual = FIFO_queue.pop_front();
	  surface_iterator = intial_face + actual.second;
	  ConvexPolygon triangle_surface = as_polygon(surface_iterator);

	  // Cut against all the planes of the Voronoi cell (use specific routine inside voronoi cell?)
	  const std::vector<ConvexPolygon> & inner_faces = this->voronoi_cells[actual.first].get_inner_faces();
	  for(auto i = 0; i<inner_faces.size(); i++){
	    bool cut = triangle_surface.cut_by_plane(inner_faces[i].supporting_plane(),i);
	    if(cut){
	      if(!incident_set(inner_faces[i].get_adiacent_polygon()), actual.surface){
		incident_set(inner_faces[i].get_adiacent_polygon(), actual.surface) = true;
		couple.surface = actual.surface;
		couple.cell = inner_faces[i].get_adiacent_polygon();
		FIFO_queue.push_back(couple);
	      }
	    }
	  }

	  // Finally, if we have still some adiacency with the surface polygons->add the couples actual cell and the close surface
	  std::vector<UInt> ad_poly = triangle_surface.get_adiacent_polygons();
	  for(auto j = 0; j < ad_poly.size(); j++){
	    if(ad_poly[i]<0){
	      if(!incident_set(actual.cell, 1-ad_poly[j])){
		incident_set(actual.cell, 1-ad_poly[j]) = true;
		couple.surface = 1-ad_poly[j];
		couple.cell = actual.cell;
		FIFO_queue.push_back(couple);
	      }
	    }
	  }

	  // Finally add the cut surface to the apporpriate zone
	  Surfaces_polygons_collection[actual.cell].push_back(triangle_surface);
	}
	
	// To conclude I need to add the set_surface_faces to each vornoi cell
	for(auto i = 0; i < this->nodes_.size(); i++){
	  this->cells_[i].set_surface_faces(Surfaces_polygons_collection[i])
	    }
      };
	      
      // cell data structure
      class VoronoiCell {
      private:
	const Voronoi* v_;
	UInt id_ = 0;
	std::vector<ConvexPolygon> InnerFaces_; // Set when unconstrained Voronoi is built   // New
	std::vector<ConvexPolygon> SurfaceFaces_; // Set with Yan's algorithm
		
	void clip_to_surface(){ // This methods clips the Inner Polygons (that may go out of the surface) to surface limits. This implementation relies on the adiacent polygons of the surface polygons.
	  // STEP 1: find Segments of interest
	  std::vector<std::list<SMatrix<3,2>>> cut_segments; // This vector contains the segments to cut each Polygon, obtained by the surfaces cells;
	  std::vector<std::list<UInt>> cut_indexes; // This vector contains the indexes of the cells corresponding to the cut we are prforming on the surface (to provide the final adiacency)
		  
	  cut_segments.resize(this->InnerFaces_.size());
	  cut_indexes.resize(this->InnerFaces_.size());	   
			
	  // Now cycle over surface and look for segments we need to cut the inner faces
	  for(auto j = 0; j < this->SurfaceFaces_.size();j++ ){
	    std::vector<SVector<3>> points = SurfaceFaces_[j].points();
	    DVector<UInt> adiacent_polygons = SurfaceFaces_[j].adiacent_polygons();
	    for(auto k = 0; k < points.size(); k++){
	      UInt adiacent = adiacent_polygons[k];
	      if(adiacent>=0){ // NOTE: if < 0 be careful, need to add 1 before abs!!!
		SMatrix<3,2> segment;
		segment.col(0) = points[k];
		if(k==points.size()){
		  segment.col(1) = points[0];
		}else{
		  segment.col(1) = points[k+1];
		}
		cut_segments[adiacent].push_back(segment);
		cut_indexes[adiacent].push_back(-j -1); // NOTE: if < 0 be careful, need to add 1 before abs!!!
	      }
	    }
	  }
		  
	  // Now we need to sort the segments for each cell cut by the border!!
	  // Reamrk: this implementation can becaome very inefficient for a large number of Internal faces - sruface faces couple, due to push_front. However,in practice  I expect 2-3 intsertions at most
	  for(auto i = 0; i < this->InnerFaces_.size(); i++){ // Each possible internal face
	    final_size = cut_segments[i].size() + 1;
	    if(cut_segments[i].size()  > 0){// at least one segment present
		      
	      // Tolerance for equivalence // Check with Palummo
	      tol = 0.0000001;
		      
	      // Create a vector of sorted points:
	      std::list<SVector<3>> cell_limit;
	      std::list<UInt> limit_neighbors;
		      
	      // Fill with the first segment
	      SMatrix<3,2> segment = (cut_segments[i]).front();
	      segments[i].pop_front();
		      
	      // Check it is counterclockwise ordered
	      bool counterclock = InnerFaces[i].check_Direction(segment); // Check direction missing, we need to implement this!!
		      
	      cell_limit.push_front(segment.col(0));
	      if(counterclock){
		cell_limit.push_back(segment.col(1));
	      }else{
		cell_limit.push_front(segment.col(1));
	      }

	      UInt current_size=2;

	      while(current_size < final_size){

		auto iterator_segments = cut_segments.begin();
		auto iterator_adiacent = cut_indexes.begin();
		bool found = false
		  while(iterator != cut_segments.end() || !found){
		    
		    if((iterator_segments->col(0) - cell_limit.front()).norm() < tol){
		      cell_limit.push_front(iterator_segments->col(1)); // add the other point
		      limit_neighbors.push_front(*iterator_adiacent);
		      found=true;
		    }
		    if((iterator_segments->col(1) - cell_limit.front().norm()) < tol){
		      cell_limit.push_front(iterator_segments->col(0)); // add the other point
		      limit_neighbors.push_front(*iterator_adiacent);
		      found=true;
		    }
		    if((iterator_segments->col(0) - cell_limit.back()).norm() < tol){
		      cell_limit.push_back(iterator_segments->col(1)); // add the other point
		      limit_neighbors.push_back(*iterator_adiacent);
		      found=true;
		    }
		    if((iterator_segments->col(1) - cell_limit.back()).norm() < tol){
		      cell_limit.push_back(iterator_segments->col(0)); // add the other point
		      limit_neighbors.push_back(*iterator_adiacent);
		      found=true;
		    }
		    
		    if(!found){
		      iterator_segments++;
		      iterator_adiacent++;
		    }else{
		      current_size++;
		    }
		  }

	      }

	      // Find the planes associated with extreme segments
	      const ConvexPolygon * plane_begin = & SurfaceFaces_[1-limit_neighbors.front()]; // 1 - front to transofrm from negative to positive
	      const ConvexPolygon * plane_end = & SurfaceFaces_[1-limit_neighbors.back()];
		
	      // Note: the line of segmetns is already orderd in the right direction. Now we need to cut the faces and finally to throw away the faces that are still unlimited
	      innerFaces[i].refine_surface(cell_limit, limit_neighbors, plane_begin, plane_end);
	    }
	    // MISSING (and probably will not be implemented)
	    // innerFaces[i].erase_out_of_bound(); // Note: we need to erase the polygons that are still infinite (i.e. case with two or one circumcenter out of surface and ramaining missing)
	  }
            
	}
	  
      public:
	VoronoiCell() = default;
	VoronoiCell(UInt id, const Voronoi* v) : v_(v), id_(id), InnerFaces_(v_->cells_.at(id_).get_inner_faces()), SurfaceFaces_(v_->cells_.at(id_).get_surface_faces()){} 
	void set_id(UInd id){id_=id;}
	void set_inner_faces(const std::vector<ConvexPolygon> & InnerFaces){InnerFaces_ = InnerFaces;}
	void set_surface_faces(const std::vector<ConvexPolygon> & SurfaceFaces){
	  SurfaceFaces_ = SurfaceFaces;
	  this->clip_to_surface(); // Clip the innter faces against surface

	  DVector<UInt> indices_out; // There may exist a Polygon of the cell that needs to be cut out
	  indices_out.resize(0);

	  for(auto i = 0; i<InnerFaces_.size(); i++){
	    if(!InnerFaces_[i].closed()){
	      indices_out.push_back(i);
	    }
	  }

	  if(indices_out.size()>0){
	    for(auto i = indices_out.size()-1; i>-1 ;i--){
	      InnerFaces.erase(i); // Throw out the extreme faces (very rare situation, in principle)
	    }
	  }
	  return;
	}
	
	// Getters
	const std::vector<ConvexPolygon> & get_inner_faces() const {return this->InnerFaces_;}
	const std::vector<ConvexPolygon> & get_surface_faces() const {return this->SurfaceFaces_;}
	  
	double measure() const { // This part is still critical, we will think in futura how to solve it
	  double volume = 0;
	  for (UInt j = 0; j < InnerFaces_.size(); ++j) {
	    double area = (InnerFaces_[i]).measure();
	    SVector<3> site = v->nodes[i]; // Check
	    HyperPlane<2,3> supp_plane = ((InnerFaces_[i]).supporting_plane());
	    double sign_dist = (site - supp_plane.project(site)).dot(supp_plane.norm());
	    volume = volume + area * sign_dist;
	  }
            
	  for (UInt j = 0; j < Surface_faces_.size(); ++j) {
	    double area = (Surface_faces_[i]).measure();
	    SVector<3> site = v->nodes[i]; // Check
	    HyperPlane<2,3> supp_plane = ((Surface_faces[i]).supporting_plane());
	    double sign_dist = (site - supp_plane.project(site)).dot(supp_plane.norm());
	    volume = volume + area * sign_dist ; // If negative, correctly subtracts to the total volume (concavity)
	  }
            
	  return  volume/3;
	}
	ConvexPolygon InnerFace(UInt i) const {
	  fdapde_assert(i < InnerFaces_.size());
	  return InnerFaces_[i];
	}
	ConvexPolygon SurfaceFace(UInt i) const {
	  fdapde_assert(i < Surface_faces.size());
	  return Surface_faces[i];
	}
	bool on_boundary() const {
	  if(Surface_faces.size()>0){
	    return true;
	  }
	  return false;   // no edge on boundary
	}
	bool contains(const SVector<3>& p) const { return v_->locate(p)[0] == id_; }
      };
      
      // FURTHER VORONOI 3D code
      
      // getters
      const DMatrix<double>& sites() const { return mesh_->nodes(); }
      SVector<embed_dim> site(UInt id) const { return mesh_->node(id); }
      const BinaryVector<fdapde::Dynamic>& boundary_vertices() const { return nodes_markers_; } // NOTE: set in the constructor, when clipped to surface called, still missing
      const Triangulation<3, 3>& dual() const { return *mesh_; }
      UInt n_nodes() const { return nodes_.rows(); }
      UInt n_cells() const { return mesh_->n_nodes(); }
      using CellType = VoronoiCell;
      CellType cell(UInt id) const { return VoronoiCell(id, this); } // Needs constructor from the Voronoi pointer!!! Look below
      // iterators
      class cell_iterator : public index_based_iterator<cell_iterator, CellType> {
	using Base = index_based_iterator<cell_iterator, CellType>;
	using Base::index_;
	friend Base;
	const Voronoi* voronoi_;
	cell_iterator& operator()(UInt i) {
	  Base::val_ = voronoi_->cell(i);
	  return *this;
	}
      public:
	cell_iterator(UInt index, const Voronoi* voronoi) : Base(index, 0, voronoi->n_cells()), voronoi_(voronoi) {
	  if (index_ < voronoi_->n_cells()) this->val_ = voronoi_->cell(index_);
	}
      };
      cell_iterator cells_begin() const { return cell_iterator(0, this); }
      cell_iterator cells_end() const { return cell_iterator(n_cells(), this); }
      // perform point location for set of points p_1, p_2, \ldots, p_n
      DVector<UInt> locate(const DMatrix<double>& locs) const { // NBB NEEDS TO BE MODIFIED BOTH HERE AND BELOW
	fdapde_assert(locs.cols() == embed_dim);
	// find delanuay cells containing locs
	DVector<UInt> dual_locs = mesh_->locate(locs);
	for (UInt i = 0; i < locs.rows(); ++i) {
	  if (dual_locs[i] == -1) continue;   // location outside domain
	  // find nearest cell to i-th location
	  typename Triangulation<2, 2>::CellType f = mesh_->cell(dual_locs[i]);
	  SMatrix<1, Triangulation<2, 2>::n_nodes_per_cell> dist =
	    (f.nodes().colwise() - locs.row(i).transpose()).colwise().squaredNorm();
	  UInt min_index;
	  dist.minCoeff(&min_index);
	  dual_locs[i] = f.node_ids()[min_index];
	}
	return dual_locs;
      }  
    private:
      const Triangulation<3, 3>* mesh_;
      DMatrix<double> nodes_;                             // voronoi vertices
      BinaryVector<fdapde::Dynamic> nodes_markers_;       // i-th element true if i-th vertex is on boundary
      std::unordered_map<UInt, std::vector<UInt>> cells_;   // for each cell id, the ids of the vertices composing it
    };

template <> class Voronoi<Triangulation<2, 2>> {
   public:
    static constexpr int local_dim = Triangulation<2,2>::local_dim;
    static constexpr int embed_dim = Triangulation<2,2>::embed_dim;

    Voronoi() = default;
    Voronoi(const Triangulation<2, 2>& mesh) : mesh_(&mesh) {   // constructs voronoi diagram from Delanoy triangulation
        int n_delaunay_faces = mesh_->n_cells();
        int n_delaunay_boundary_edges = mesh_->n_boundary_edges();
        nodes_.resize(n_delaunay_faces + n_delaunay_boundary_edges + mesh_->n_boundary_nodes(), embed_dim);
        nodes_markers_.resize(nodes_.rows());
        int k = n_delaunay_faces;
        for (typename Triangulation<2, 2>::cell_iterator it = mesh_->cells_begin(); it != mesh_->cells_end(); ++it) {
            nodes_.row(it->id()) = it->circumcenter();
            for (int v : it->node_ids()) { cells_[v].push_back(it->id()); }
            if (it->on_boundary()) {
                for (typename Triangulation<2, 2>::CellType::edge_iterator jt = it->edges_begin();
                     jt != it->edges_end(); ++jt) {
                    if (jt->on_boundary()) {
                        nodes_.row(k) = jt->supporting_plane().project(nodes_.row(it->id()));
                        nodes_markers_.set(k);
                        for (int v : jt->node_ids()) { cells_[v].push_back(k); }
                        k++;
                    }
                }
            }
        }
        // augment node set with boundary vertices, sort each cell clockwise (around its mean point)
        for (auto& [key, value] : cells_) {
            if (mesh_->is_node_on_boundary(key)) {
                nodes_.row(k) = mesh_->node(key);
                nodes_markers_.set(k);
                value.push_back(k);
                k++;
            }
            SVector<embed_dim> mean = SVector<embed_dim>::Zero();
            auto compare = clockwise_order<SVector<embed_dim>>(
              std::accumulate(
                value.begin(), value.end(), mean, [&](const auto& c, int a) { return c + nodes_.row(a).transpose(); }) /
              value.size());
            std::sort(value.begin(), value.end(), [&](int i, int j) { return compare(nodes_.row(i), nodes_.row(j)); });
        }
    }

    // cell data structure
    class VoronoiCell {
       private:
        const Voronoi* v_;
        int id_ = 0;
        int n_edges_ = 0;
       public:
        VoronoiCell() = default;
        VoronoiCell(int id, const Voronoi* v) : v_(v), id_(id), n_edges_(v_->cells_.at(id_).size()) { }
        // matrix of edge identifiers
        DMatrix<int> edges() const {
            DMatrix<int> result;
            result.resize(n_edges_, local_dim);
            for (int j = 0; j < n_edges_; ++j) {
                for (int k = 0; k < local_dim; ++k) result(j, k) = v_->cells_.at(id_)[(j + k) % n_edges_];
            }
            return result;
        }
        double measure() const {
            double area = 0;
            for (int j = 0; j < n_edges_; ++j) {
                // compute doubled area of triangle connecting the j-th edge and the center (use cross product)
                SVector<embed_dim> x = v_->vertex(v_->cells_.at(id_)[j]);
                SVector<embed_dim> y = v_->vertex(v_->cells_.at(id_)[(j + 1) % n_edges_]);
                area += x[0] * y[1] - x[1] * y[0];
            }
            return 0.5 * std::abs(area);
        }
        Simplex<1, 2> edge(int i) const {
            fdapde_assert(i < n_edges_);
            SMatrix<embed_dim, 2> coords;
            for (int k = 0; k < embed_dim; ++k) { coords.col(k) = v_->vertex(v_->cells_.at(id_)[(i + k) % n_edges_]); }
            return Simplex<1, 2>(coords);
        }
        bool on_boundary() const {
            for (int j = 0; j < n_edges_; ++j) {
                bool boundary = true;
                for (int k = 0; k < local_dim; ++k)
                    boundary &= v_->nodes_markers_[v_->cells_.at(id_)[(j + k) % n_edges_]];
                if (boundary == true) return true;
            }
            return false;   // no edge on boundary
        }
        bool contains(const SVector<embed_dim>& p) const { return v_->locate(p)[0] == id_; }
    };
    // getters
    const DMatrix<double>& sites() const { return mesh_->nodes(); }
    SVector<embed_dim> vertex(int id) const { return nodes_.row(id); }
    SVector<embed_dim> site(int id) const { return mesh_->node(id); }
    const BinaryVector<fdapde::Dynamic>& boundary_vertices() const { return nodes_markers_; }
    const DMatrix<double>& vertices() const { return nodes_; }
    const Triangulation<2, 2>& dual() const { return *mesh_; }
    int n_nodes() const { return nodes_.rows(); }
    int n_cells() const { return mesh_->n_nodes(); }
    // compute matrix of edges
    DMatrix<int> edges() const {
        std::unordered_set<std::array<int, local_dim>, std_array_hash<int, local_dim>> visited;
        std::array<int, local_dim> edge;
        for (const auto& [key, value] : cells_) {
            int n_edges = value.size();
            for (int j = 0; j < n_edges; ++j) {
                for (int k = 0; k < local_dim; ++k) { edge[k] = value[(j + k) % n_edges]; }
                std::sort(edge.begin(), edge.end());
                if (visited.find(edge) == visited.end()) { visited.insert(edge); }
            }
        }
        DMatrix<int> result;
        result.resize(visited.size(), local_dim);
        int i = 0;
        for (const auto& e : visited) {
            for (int k = 0; k < local_dim; ++k) result(i, k) = e[k];
            i++;
        }
        return result;
    }
    using CellType = VoronoiCell;
    CellType cell(int id) const { return VoronoiCell(id, this); }
    // iterators
    class cell_iterator : public index_based_iterator<cell_iterator, CellType> {
        using Base = index_based_iterator<cell_iterator, CellType>;
        using Base::index_;
        friend Base;
        const Voronoi* voronoi_;
        cell_iterator& operator()(int i) {
            Base::val_ = voronoi_->cell(i);
            return *this;
        }
       public:
        cell_iterator(int index, const Voronoi* voronoi) : Base(index, 0, voronoi->n_cells()), voronoi_(voronoi) {
            if (index_ < voronoi_->n_cells()) this->val_ = voronoi_->cell(index_);
        }
    };
    cell_iterator cells_begin() const { return cell_iterator(0, this); }
    cell_iterator cells_end() const { return cell_iterator(n_cells(), this); }
    // perform point location for set of points p_1, p_2, \ldots, p_n
    DVector<int> locate(const DMatrix<double>& locs) const {
        fdapde_assert(locs.cols() == embed_dim);
        // find delanuay cells containing locs
        DVector<int> dual_locs = mesh_->locate(locs);
        for (int i = 0; i < locs.rows(); ++i) {
            if (dual_locs[i] == -1) continue;   // location outside domain
            // find nearest cell to i-th location
            typename Triangulation<2, 2>::CellType f = mesh_->cell(dual_locs[i]);
            SMatrix<1, Triangulation<2, 2>::n_nodes_per_cell> dist =
              (f.nodes().colwise() - locs.row(i).transpose()).colwise().squaredNorm();
            int min_index;
            dist.minCoeff(&min_index);
            dual_locs[i] = f.node_ids()[min_index];
        }
        return dual_locs;
    }  
   private:
    const Triangulation<2, 2>* mesh_;
    DMatrix<double> nodes_;                             // voronoi vertices
    BinaryVector<fdapde::Dynamic> nodes_markers_;       // i-th element true if i-th vertex is on boundary
    std::unordered_map<int, std::vector<int>> cells_;   // for each cell id, the ids of the vertices composing it
};

template <> class Voronoi<Triangulation<1, 1>> {
   public:
    static constexpr int local_dim = Triangulation<1, 1>::local_dim;
    static constexpr int embed_dim = Triangulation<1, 1>::embed_dim;

    Voronoi() = default;
    Voronoi(const Triangulation<1, 1>& mesh) : mesh_(&mesh) {   // constructs voronoi diagram from Delanoy triangulation
        int n_delaunay_faces = mesh_->n_cells();
        nodes_.resize(n_delaunay_faces + 2, embed_dim);
        nodes_markers_.resize(nodes_.rows());
        int k = n_delaunay_faces;
        for (typename Triangulation<1, 1>::cell_iterator it = mesh_->cells_begin(); it != mesh_->cells_end(); ++it) {
            nodes_.row(it->id()) = it->circumcenter();
            for (int v : it->node_ids()) { cells_[v].push_back(it->id()); }
            if (it->on_boundary()) {
                for (int i = 0; i < Triangulation<1, 1>::n_nodes_per_cell; ++i) {
                    if (mesh_->is_node_on_boundary(it->node_ids()[i])) {
                        nodes_.row(k) = mesh_->node(it->node_ids()[i]);
                        nodes_markers_.set(k);
                        cells_[it->node_ids()[i]].push_back(k);
                        k++;
                    }
                }
            }
        }
        // sort each cell clockwise (around its mean point)
        for (auto& [key, value] : cells_) {
            if (value[1] < value[0]) std::swap(value[0], value[1]);
        }
    }
    // cell data structure
    class VoronoiCell {
       private:
        const Voronoi* v_;
        int id_ = 0;
       public:
        VoronoiCell() = default;
        VoronoiCell(int id, const Voronoi* v) : v_(v), id_(id) { }
      double measure() const { return (v_->vertex(v_->cells_.at(id_)[1]) - v_->vertex(v_->cells_.at(id_)[0])).norm(); }
        bool on_boundary() const {
            return v_->nodes_markers_[v_->cells_.at(id_)[0]] || v_->nodes_markers_[v_->cells_.at(id_)[1]];
        }
        bool contains(const SVector<embed_dim>& p) const { return v_->locate(p)[0] == id_; }
    };
    // getters
    const DVector<double>& sites() const { return mesh_->nodes(); }
    SVector<embed_dim> vertex(int id) const { return nodes_.row(id); }
    SVector<embed_dim> site(int id) const { return mesh_->node(id); }
    const BinaryVector<fdapde::Dynamic>& boundary_vertices() const { return nodes_markers_; }
    const DMatrix<double>& vertices() const { return nodes_; }
    const Triangulation<1, 1>& dual() const { return *mesh_; }
    int n_nodes() const { return nodes_.rows(); }
    int n_cells() const { return mesh_->n_nodes(); }
    using CellType = VoronoiCell;
    CellType cell(int id) const { return VoronoiCell(id, this); }
    // iterators
    class cell_iterator : public index_based_iterator<cell_iterator, CellType> {
        using Base = index_based_iterator<cell_iterator, CellType>;
        using Base::index_;
        friend Base;
        const Voronoi* voronoi_;
        cell_iterator& operator()(int i) {
            Base::val_ = voronoi_->cell(i);
            return *this;
        }
       public:
        cell_iterator(int index, const Voronoi* voronoi) : Base(index, 0, voronoi->n_cells()), voronoi_(voronoi) {
            if (index_ < voronoi_->n_cells()) this->val_ = voronoi_->cell(index_);
        }
    };
    cell_iterator cells_begin() const { return cell_iterator(0, this); }
    cell_iterator cells_end() const { return cell_iterator(n_cells(), this); }
    // perform point location for set of points p_1, p_2, \ldots, p_n
    DVector<int> locate(const DMatrix<double>& locs) const {
        fdapde_assert(locs.cols() == embed_dim);
        // find delanuay cells containing locs
        DVector<int> dual_locs = mesh_->locate(locs);
        for (int i = 0; i < locs.rows(); ++i) {
            if (dual_locs[i] == -1) continue;   // location outside domain
            // find nearest cell to i-th location
            typename Triangulation<1, 1>::CellType f = mesh_->cell(dual_locs[i]);
            SMatrix<1, Triangulation<1, 1>::n_nodes_per_cell> dist =
              (f.nodes().colwise() - locs.row(i).transpose()).colwise().squaredNorm();
            int min_index;
            dist.minCoeff(&min_index);
            dual_locs[i] = f.node_ids()[min_index];
        }
        return dual_locs;
    }
   private:
    const Triangulation<1, 1>* mesh_;
    DMatrix<double> nodes_;                             // voronoi vertices
    BinaryVector<fdapde::Dynamic> nodes_markers_;       // i-th element true if i-th vertex is on boundary
    std::unordered_map<int, std::vector<int>> cells_;   // for each cell id, the ids of the vertices composing it
};
  
}   // namespace core
}   // namespace fdapde

#endif   // __VORONOI_H__
